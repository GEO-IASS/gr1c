<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>gr1c: automaton.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="gr1cdoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gr1c
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">automaton.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Routines for working with a strategy, as a finite automaton.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="common_8h.html">common.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ptree_8h.html">ptree.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structanode__t.html">anode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy automaton nodes.  <a href="structanode__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2f380c751f91c6f27c8b8ca8c34c4ac2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f380c751f91c6f27c8b8ca8c34c4ac2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___dot_dump_flags.html#ga2f380c751f91c6f27c8b8ca8c34c4ac2">DOT_AUT_ALL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2f380c751f91c6f27c8b8ca8c34c4ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show all variables with values. <br/></td></tr>
<tr class="separator:ga2f380c751f91c6f27c8b8ca8c34c4ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a4e537f3f20d76ed8d98247da74d75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae2a4e537f3f20d76ed8d98247da74d75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___dot_dump_flags.html#gae2a4e537f3f20d76ed8d98247da74d75">DOT_AUT_BINARY</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gae2a4e537f3f20d76ed8d98247da74d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume variables have Boolean domains, and only label nodes with those that are True. <br/></td></tr>
<tr class="separator:gae2a4e537f3f20d76ed8d98247da74d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274bae2c00790303c7690b97ab7ae104"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga274bae2c00790303c7690b97ab7ae104"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___dot_dump_flags.html#ga274bae2c00790303c7690b97ab7ae104">DOT_AUT_EDGEINPUT</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga274bae2c00790303c7690b97ab7ae104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show environment variables on edges. <br/></td></tr>
<tr class="separator:ga274bae2c00790303c7690b97ab7ae104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43296551a53d0f526ed5224d1f407e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___dot_dump_flags.html#gaf43296551a53d0f526ed5224d1f407e4">DOT_AUT_ATTRIB</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gaf43296551a53d0f526ed5224d1f407e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show node attributes.  <a href="group___dot_dump_flags.html#gaf43296551a53d0f526ed5224d1f407e4"></a><br/></td></tr>
<tr class="separator:gaf43296551a53d0f526ed5224d1f407e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aebf26a051f8f3e1bb94ac6d046ff4efa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebf26a051f8f3e1bb94ac6d046ff4efa"></a>
typedef struct <a class="el" href="structanode__t.html">anode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aebf26a051f8f3e1bb94ac6d046ff4efa">anode_t</a></td></tr>
<tr class="memdesc:aebf26a051f8f3e1bb94ac6d046ff4efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy automaton nodes. <br/></td></tr>
<tr class="separator:aebf26a051f8f3e1bb94ac6d046ff4efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0d192e6b79400bb306fec2e717de6e53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a0d192e6b79400bb306fec2e717de6e53">insert_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, int rgrad, bool *state, int state_len)</td></tr>
<tr class="separator:a0d192e6b79400bb306fec2e717de6e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6e451c56cf9ed34916afa860221490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aea6e451c56cf9ed34916afa860221490">pop_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:aea6e451c56cf9ed34916afa860221490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fdc2503bab2b3825dec448e4591a9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a51fdc2503bab2b3825dec448e4591a9c">build_anode_trans</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, bool *state, int state_len, int next_mode, bool **next_states, int next_len)</td></tr>
<tr class="separator:a51fdc2503bab2b3825dec448e4591a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cffb115c3f76898edfa068dc043d7fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a0cffb115c3f76898edfa068dc043d7fb">append_anode_trans</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, bool *state, int state_len, int next_mode, bool *next_state)</td></tr>
<tr class="separator:a0cffb115c3f76898edfa068dc043d7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d83d23bb5b7852073887dd68d04f00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ad5d83d23bb5b7852073887dd68d04f00">find_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, bool *state, int state_len)</td></tr>
<tr class="separator:ad5d83d23bb5b7852073887dd68d04f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9b2b8c3fe376f97aeea78a662bb64c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#adc9b2b8c3fe376f97aeea78a662bb64c">find_anode_index</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, bool *state, int state_len)</td></tr>
<tr class="separator:adc9b2b8c3fe376f97aeea78a662bb64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2058a2959949782553b2f4bf3302fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a1c2058a2959949782553b2f4bf3302fa">delete_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> *target)</td></tr>
<tr class="separator:a1c2058a2959949782553b2f4bf3302fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69834ddebd4ca217886025375182f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#af69834ddebd4ca217886025375182f19">replace_anode_trans</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> *old, <a class="el" href="structanode__t.html">anode_t</a> *new)</td></tr>
<tr class="separator:af69834ddebd4ca217886025375182f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7c3c8f7ffdfaa59b6455bc54e90cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#adda7c3c8f7ffdfaa59b6455bc54e90cb">aut_prune_deadends</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:adda7c3c8f7ffdfaa59b6455bc54e90cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad135af09f28e95ad66d501893df662d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ad135af09f28e95ad66d501893df662d6">tulip_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, FILE *fp)</td></tr>
<tr class="separator:ad135af09f28e95ad66d501893df662d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa042707aac1b8820ab74ae4272068284"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa042707aac1b8820ab74ae4272068284">dot_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, unsigned char format_flags, FILE *fp)</td></tr>
<tr class="separator:aa042707aac1b8820ab74ae4272068284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0084e8abf09eed89cd7aa2acc03e15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#acb0084e8abf09eed89cd7aa2acc03e15">list_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int state_len, FILE *fp)</td></tr>
<tr class="separator:acb0084e8abf09eed89cd7aa2acc03e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7280119d68f6970fc7146b20833ffd63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a7280119d68f6970fc7146b20833ffd63">aut_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int state_len, FILE *fp)</td></tr>
<tr class="separator:a7280119d68f6970fc7146b20833ffd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88038233d4f53e8d4746c8d1bd12064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa88038233d4f53e8d4746c8d1bd12064">aut_aut_load</a> (int state_len, FILE *fp)</td></tr>
<tr class="separator:aa88038233d4f53e8d4746c8d1bd12064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cb2e6e6ecbabd19b75c00ecef27278"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ad5cb2e6e6ecbabd19b75c00ecef27278">aut_size</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:ad5cb2e6e6ecbabd19b75c00ecef27278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6003bf5e6d68756a2ff99dfd86d1b2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a6003bf5e6d68756a2ff99dfd86d1b2f4">delete_aut</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:a6003bf5e6d68756a2ff99dfd86d1b2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4368ebc029183cee05914b7fe6cf5f49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a4368ebc029183cee05914b7fe6cf5f49">forward_modereach</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> *node, int mode, bool **N, int N_len, int magic_mode, int state_len)</td></tr>
<tr class="separator:a4368ebc029183cee05914b7fe6cf5f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Routines for working with a strategy, as a finite automaton. </p>
<p>A node is uniquely determined by its state and goal mode. Thus other attributes such as values for a reach annotation are not required when invoking some functions. Note that the length of the state vector in each node is not stored anywhere in this data structure. It is assumed to be positive and constant for a particular automaton (strategy).</p>
<p>SCL; 2012. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0cffb115c3f76898edfa068dc043d7fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* append_anode_trans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>next_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append transition to array for the node with given state and mode. Return new head on success, NULL on error. </p>

</div>
</div>
<a class="anchor" id="a7280119d68f6970fc7146b20833ffd63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aut_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump strategy using "gr1c automaton" file format. See <a href="md_formats.html">external_notes</a> for details. If fp = NULL, then write to stdout. </p>

</div>
</div>
<a class="anchor" id="aa88038233d4f53e8d4746c8d1bd12064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* aut_aut_load </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load strategy given in "gr1c automaton" format from file fp. See <a href="md_formats.html">external_notes</a> for details. If fp = NULL, then read from stdin. Return resulting head pointer, or NULL if error. </p>

</div>
</div>
<a class="anchor" id="adda7c3c8f7ffdfaa59b6455bc54e90cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* aut_prune_deadends </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return (possibly new) head pointer. </p>

</div>
</div>
<a class="anchor" id="ad5cb2e6e6ecbabd19b75c00ecef27278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aut_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get number of nodes in given automaton. </p>

</div>
</div>
<a class="anchor" id="a51fdc2503bab2b3825dec448e4591a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* build_anode_trans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool **&#160;</td>
          <td class="paramname"><em>next_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the transition array for the node with given state and mode.</p>
<p>next_states is an array of state vectors, with length next_len, used to build transitions for this node. All of these states have mode next_mode.</p>
<p>If the base node already has a transition array, then it is not replaced until the new array has been successfully built. (That is, if error, the original node should be unaffected.)</p>
<p>Return given head on success, NULL if one of the needed nodes is not found. </p>

</div>
</div>
<a class="anchor" id="a1c2058a2959949782553b2f4bf3302fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* delete_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return (possibly new) head pointer. Transition arrays are not altered by this function. </p>

</div>
</div>
<a class="anchor" id="a6003bf5e6d68756a2ff99dfd86d1b2f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_aut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete entire automaton pointed to by given head.</p>
<p>Essentially, traverses node list and frees them and their member data. At completion, the given head pointer is no longer valid. Invoking with NULL pointer causes return with no error. </p>

</div>
</div>
<a class="anchor" id="aa042707aac1b8820ab74ae4272068284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dot_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>format_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump DOT file describing the automaton (strategy). See <a class="el" href="group___dot_dump_flags.html">format flags for dot_aut_dump</a>. Also see comments for <a class="el" href="automaton_8h.html#ad135af09f28e95ad66d501893df662d6">tulip_aut_dump()</a>. </p>

</div>
</div>
<a class="anchor" id="ad5d83d23bb5b7852073887dd68d04f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* find_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return pointer to node with given state and mode, or NULL if not found. </p>

</div>
</div>
<a class="anchor" id="adc9b2b8c3fe376f97aeea78a662bb64c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_anode_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the position of the node with given state and mode, or -1 if not found. 0-based indexing. </p>

</div>
</div>
<a class="anchor" id="a4368ebc029183cee05914b7fe6cf5f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int forward_modereach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool **&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>magic_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute forward reachable set from node in automaton pointed to by head, restricting attention to nodes with state in N and goal mode of mode, and setting the mode field of each reached node to magic_mode. Return zero on success, nonzero on error. </p>

</div>
</div>
<a class="anchor" id="a0d192e6b79400bb306fec2e717de6e53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* insert_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert node at the front of the given node list. If given head is NULL, a new list will be created.</p>
<p>Return new head on success, NULL on error. </p>

</div>
</div>
<a class="anchor" id="acb0084e8abf09eed89cd7aa2acc03e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump list of nodes; mostly useful for debugging. If fp = NULL, then write to stdout. The basic format is </p>
<pre class="fragment">i : S - m - r - [t0 t1 ...]
</pre><p>where i is the node ID (used only as a means to uniquely refer to nodes), S is the state (as a bitvector) at that node, m is the goal mode, r is the reach annotation value, and [t0 t1 ...] is the list of IDs of nodes reachable in one step. </p>

</div>
</div>
<a class="anchor" id="aea6e451c56cf9ed34916afa860221490"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* pop_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete topmost (head) node from list. Return pointer to new head. </p>

</div>
</div>
<a class="anchor" id="af69834ddebd4ca217886025375182f19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void replace_anode_trans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace all occurrences of "old" with "new" in transition arrays. If "new" is NULL, then the transitions into "old" are deleted and all dependent transition array lengths are decremented. </p>

</div>
</div>
<a class="anchor" id="ad135af09f28e95ad66d501893df662d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tulip_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump tulipcon XML file describing the automaton (strategy). Variable names are obtained from evar_list and svar_list, in which the combined order is assumed to match that of the state vector in each automaton node.</p>
<p>For each node, the goal mode and reach annotation value are placed in a &lt;name&gt; tag in that order.</p>
<p>If fp = NULL, then write to stdout. Return nonzero if error. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 2 2012 23:08:07 for gr1c by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
