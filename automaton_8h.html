<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>gr1c: automaton.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="gr1cdoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gr1c
   &#160;<span id="projectnumber">0.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">automaton.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Routines for working with a strategy, as a finite automaton.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &quot;<a class="el" href="common_8h.html">common.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ptree_8h.html">ptree.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for automaton.h:</div>
<div class="dyncontent">
<div class="center"><img src="automaton_8h__incl.png" border="0" usemap="#automaton_8h" alt=""/></div>
<map name="automaton_8h" id="automaton_8h">
<area shape="rect" id="node3" href="common_8h.html" title="Project&#45;wide definitions and macros. " alt="" coords="101,80,184,107"/><area shape="rect" id="node4" href="ptree_8h.html" title="Routines for working with a GR(1) formula parse tree. " alt="" coords="47,155,110,181"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="automaton_8h__dep__incl.png" border="0" usemap="#automaton_8hdep" alt=""/></div>
<map name="automaton_8hdep" id="automaton_8hdep">
<area shape="rect" id="node2" href="solve_8h.html" title="Compute realizability and a strategy for a GR(1) game. " alt="" coords="5,80,69,107"/><area shape="rect" id="node3" href="patching_8h.html" title="Implementation of patching and incremental synthesis algorithms. " alt="" coords="93,80,176,107"/><area shape="rect" id="node4" href="sim_8h.html" title="Simulation support. " alt="" coords="201,80,255,107"/></map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structanode__t.html">anode_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy automaton nodes.  <a href="structanode__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga2f380c751f91c6f27c8b8ca8c34c4ac2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2f380c751f91c6f27c8b8ca8c34c4ac2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DotDumpFlags.html#ga2f380c751f91c6f27c8b8ca8c34c4ac2">DOT_AUT_ALL</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga2f380c751f91c6f27c8b8ca8c34c4ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show all variables with values. <br /></td></tr>
<tr class="separator:ga2f380c751f91c6f27c8b8ca8c34c4ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf43296551a53d0f526ed5224d1f407e4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DotDumpFlags.html#gaf43296551a53d0f526ed5224d1f407e4">DOT_AUT_ATTRIB</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:gaf43296551a53d0f526ed5224d1f407e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show node attributes.  <a href="group__DotDumpFlags.html#gaf43296551a53d0f526ed5224d1f407e4">More...</a><br /></td></tr>
<tr class="separator:gaf43296551a53d0f526ed5224d1f407e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a4e537f3f20d76ed8d98247da74d75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae2a4e537f3f20d76ed8d98247da74d75"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DotDumpFlags.html#gae2a4e537f3f20d76ed8d98247da74d75">DOT_AUT_BINARY</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:gae2a4e537f3f20d76ed8d98247da74d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume variables have Boolean domains, and only label nodes with those that are True. <br /></td></tr>
<tr class="separator:gae2a4e537f3f20d76ed8d98247da74d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274bae2c00790303c7690b97ab7ae104"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga274bae2c00790303c7690b97ab7ae104"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__DotDumpFlags.html#ga274bae2c00790303c7690b97ab7ae104">DOT_AUT_EDGEINPUT</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ga274bae2c00790303c7690b97ab7ae104"><td class="mdescLeft">&#160;</td><td class="mdescRight">Show environment variables on edges. <br /></td></tr>
<tr class="separator:ga274bae2c00790303c7690b97ab7ae104"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aebf26a051f8f3e1bb94ac6d046ff4efa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aebf26a051f8f3e1bb94ac6d046ff4efa"></a>
typedef struct <a class="el" href="structanode__t.html">anode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aebf26a051f8f3e1bb94ac6d046ff4efa">anode_t</a></td></tr>
<tr class="memdesc:aebf26a051f8f3e1bb94ac6d046ff4efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strategy automaton nodes. <br /></td></tr>
<tr class="separator:aebf26a051f8f3e1bb94ac6d046ff4efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa61aa0ed3574d98e39ecb49e308b737a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa61aa0ed3574d98e39ecb49e308b737a">anode_index</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> *node)</td></tr>
<tr class="separator:aa61aa0ed3574d98e39ecb49e308b737a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19117fcc49ec68e9ded2509805151220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a19117fcc49ec68e9ded2509805151220">append_anode_trans</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, vartype *state, int state_len, int next_mode, vartype *next_state)</td></tr>
<tr class="separator:a19117fcc49ec68e9ded2509805151220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7280119d68f6970fc7146b20833ffd63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a7280119d68f6970fc7146b20833ffd63">aut_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int state_len, FILE *fp)</td></tr>
<tr class="separator:a7280119d68f6970fc7146b20833ffd63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1ee46d08bdd897ae13d09e50771523"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aab1ee46d08bdd897ae13d09e50771523">aut_aut_dumpver</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int state_len, FILE *fp, int version)</td></tr>
<tr class="separator:aab1ee46d08bdd897ae13d09e50771523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88038233d4f53e8d4746c8d1bd12064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa88038233d4f53e8d4746c8d1bd12064">aut_aut_load</a> (int state_len, FILE *fp)</td></tr>
<tr class="separator:aa88038233d4f53e8d4746c8d1bd12064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067126ca7da0a5fde4f540fda603b32a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a067126ca7da0a5fde4f540fda603b32a">aut_aut_loadver</a> (int state_len, FILE *fp, int *version)</td></tr>
<tr class="separator:a067126ca7da0a5fde4f540fda603b32a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed4487bcde54e28bc052775df303abb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a9ed4487bcde54e28bc052775df303abb">aut_compact_nonbool</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, char *name, int maxval)</td></tr>
<tr class="separator:a9ed4487bcde54e28bc052775df303abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ce2f635a2a35a4ed1e50f1e01dd54b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ad9ce2f635a2a35a4ed1e50f1e01dd54b">aut_expand_bool</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, <a class="el" href="structptree__t.html">ptree_t</a> *nonbool_var_list)</td></tr>
<tr class="separator:ad9ce2f635a2a35a4ed1e50f1e01dd54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda7c3c8f7ffdfaa59b6455bc54e90cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#adda7c3c8f7ffdfaa59b6455bc54e90cb">aut_prune_deadends</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:adda7c3c8f7ffdfaa59b6455bc54e90cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cb2e6e6ecbabd19b75c00ecef27278"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ad5cb2e6e6ecbabd19b75c00ecef27278">aut_size</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:ad5cb2e6e6ecbabd19b75c00ecef27278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa891331c0240fd76c11421f50e2653e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa891331c0240fd76c11421f50e2653e3">build_anode_trans</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, vartype *state, int state_len, int next_mode, vartype **next_states, int next_len)</td></tr>
<tr class="separator:aa891331c0240fd76c11421f50e2653e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2058a2959949782553b2f4bf3302fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a1c2058a2959949782553b2f4bf3302fa">delete_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> *target)</td></tr>
<tr class="separator:a1c2058a2959949782553b2f4bf3302fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6003bf5e6d68756a2ff99dfd86d1b2f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a6003bf5e6d68756a2ff99dfd86d1b2f4">delete_aut</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:a6003bf5e6d68756a2ff99dfd86d1b2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa042707aac1b8820ab74ae4272068284"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aa042707aac1b8820ab74ae4272068284">dot_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, unsigned char format_flags, FILE *fp)</td></tr>
<tr class="separator:aa042707aac1b8820ab74ae4272068284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0921457452ddc98b3fcf28ec8dd9a9c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a0921457452ddc98b3fcf28ec8dd9a9c5">find_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, vartype *state, int state_len)</td></tr>
<tr class="separator:a0921457452ddc98b3fcf28ec8dd9a9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6e4b0af816787fd51d57884a58fa93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a5c6e4b0af816787fd51d57884a58fa93">find_anode_index</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, vartype *state, int state_len)</td></tr>
<tr class="separator:a5c6e4b0af816787fd51d57884a58fa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea5d34a7e37ffc8e17a717db52e41e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a0ea5d34a7e37ffc8e17a717db52e41e5">forward_modereach</a> (<a class="el" href="structanode__t.html">anode_t</a> *node, int mode, vartype **N, int N_len, int magic_mode, int state_len)</td></tr>
<tr class="separator:a0ea5d34a7e37ffc8e17a717db52e41e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703c9ee45cce2fa6963c08c6e47ae36d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a703c9ee45cce2fa6963c08c6e47ae36d">forward_prune</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> **U, int U_len)</td></tr>
<tr class="separator:a703c9ee45cce2fa6963c08c6e47ae36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f4ed14e45b2acfbc744d1311a5378f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a37f4ed14e45b2acfbc744d1311a5378f">insert_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int mode, int rgrad, bool initial, vartype *state, int state_len)</td></tr>
<tr class="separator:a37f4ed14e45b2acfbc744d1311a5378f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8e5e021f2e1f64687936957440de5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#acf8e5e021f2e1f64687936957440de5e">json_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, FILE *fp)</td></tr>
<tr class="separator:acf8e5e021f2e1f64687936957440de5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0084e8abf09eed89cd7aa2acc03e15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#acb0084e8abf09eed89cd7aa2acc03e15">list_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, int state_len, FILE *fp)</td></tr>
<tr class="separator:acb0084e8abf09eed89cd7aa2acc03e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6e451c56cf9ed34916afa860221490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#aea6e451c56cf9ed34916afa860221490">pop_anode</a> (<a class="el" href="structanode__t.html">anode_t</a> *head)</td></tr>
<tr class="separator:aea6e451c56cf9ed34916afa860221490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69834ddebd4ca217886025375182f19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#af69834ddebd4ca217886025375182f19">replace_anode_trans</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structanode__t.html">anode_t</a> *old, <a class="el" href="structanode__t.html">anode_t</a> *new)</td></tr>
<tr class="separator:af69834ddebd4ca217886025375182f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85baecde070f1027d3e581df5e74010"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ae85baecde070f1027d3e581df5e74010">spin_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, <a class="el" href="structptree__t.html">ptree_t</a> *env_init, <a class="el" href="structptree__t.html">ptree_t</a> *sys_init, <a class="el" href="structptree__t.html">ptree_t</a> **env_trans_array, int et_array_len, <a class="el" href="structptree__t.html">ptree_t</a> **sys_trans_array, int st_array_len, <a class="el" href="structptree__t.html">ptree_t</a> **env_goals, int num_env_goals, <a class="el" href="structptree__t.html">ptree_t</a> **sys_goals, int num_sys_goals, FILE *fp)</td></tr>
<tr class="separator:ae85baecde070f1027d3e581df5e74010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ce928c0c55d6482bc6b6a0e7135240"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#a67ce928c0c55d6482bc6b6a0e7135240">tulip0_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, FILE *fp)</td></tr>
<tr class="separator:a67ce928c0c55d6482bc6b6a0e7135240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad135af09f28e95ad66d501893df662d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="automaton_8h.html#ad135af09f28e95ad66d501893df662d6">tulip_aut_dump</a> (<a class="el" href="structanode__t.html">anode_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *evar_list, <a class="el" href="structptree__t.html">ptree_t</a> *svar_list, FILE *fp)</td></tr>
<tr class="separator:ad135af09f28e95ad66d501893df662d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Routines for working with a strategy, as a finite automaton. </p>
<p>Note that the length of the state vector in each node is not stored anywhere in this data structure. It is assumed to be positive and constant for a particular automaton (strategy).</p>
<p>SCL; 2012-2015 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aa61aa0ed3574d98e39ecb49e308b737a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int anode_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the position of the given node, or -1 if not found. 0-based indexing. </p>

</div>
</div>
<a class="anchor" id="a19117fcc49ec68e9ded2509805151220"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* append_anode_trans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>next_state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append transition to array for the first node with given state and mode. Return new head on success, NULL on error. </p>

</div>
</div>
<a class="anchor" id="a7280119d68f6970fc7146b20833ffd63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void aut_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump strategy using the current version of the "gr1c automaton" file format. Read <a href="md_formats.html">external_notes</a> for details. If fp = NULL, then write to stdout. </p>

</div>
</div>
<a class="anchor" id="aab1ee46d08bdd897ae13d09e50771523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aut_aut_dumpver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump strategy using the specified version of the "gr1c automaton" file format. This function is wrapped by <a class="el" href="automaton_8h.html#a7280119d68f6970fc7146b20833ffd63">aut_aut_dump()</a>. Return 0 on success. If the given version number is not supported, then return -1. </p>

</div>
</div>
<a class="anchor" id="aa88038233d4f53e8d4746c8d1bd12064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* aut_aut_load </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Legacy wrapper for <a class="el" href="automaton_8h.html#aa88038233d4f53e8d4746c8d1bd12064">aut_aut_load()</a>. Equivalent to calling <a class="el" href="automaton_8h.html#a067126ca7da0a5fde4f540fda603b32a">aut_aut_loadver()</a> with version == NULL </p>

</div>
</div>
<a class="anchor" id="a067126ca7da0a5fde4f540fda603b32a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* aut_aut_loadver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load strategy given in "gr1c automaton" format from file fp. Read <a href="md_formats.html">external_notes</a> for details. If fp = NULL, then read from stdin. Return resulting head pointer, or NULL if error. If version is not NULL, then the detected format version number is placed in *version.</p>
<p>Note that attempting to load a gr1c automaton file for a version that includes fields not present in this build of gr1c results in a warning message while all supported fields are used. If expected fields are missing (e.g., no rgrad number is available), then the appropriate "unset" indicator is set to each such field; typically this is -1, check the definition of <a class="el" href="structanode__t.html" title="Strategy automaton nodes. ">anode_t</a> for details. </p>

</div>
</div>
<a class="anchor" id="a9ed4487bcde54e28bc052775df303abb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aut_compact_nonbool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert binary-expanded form of a variable back into nonboolean. The domain of the variable is [0,maxval], and to indicate this the value field is set to maxval in the resulting (merged) variable entry (in evar_list or svar_list). Returns the new state vector length, or -1 on error. </p>

</div>
</div>
<a class="anchor" id="ad9ce2f635a2a35a4ed1e50f1e01dd54b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aut_expand_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>nonbool_var_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inverse operation of <a class="el" href="automaton_8h.html#a9ed4487bcde54e28bc052775df303abb">aut_compact_nonbool()</a>. Return zero on success, nonzero on error. </p>

</div>
</div>
<a class="anchor" id="adda7c3c8f7ffdfaa59b6455bc54e90cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* aut_prune_deadends </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return (possibly new) head pointer. </p>

</div>
</div>
<a class="anchor" id="ad5cb2e6e6ecbabd19b75c00ecef27278"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int aut_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get number of nodes in given automaton. </p>

</div>
</div>
<a class="anchor" id="aa891331c0240fd76c11421f50e2653e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* build_anode_trans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype **&#160;</td>
          <td class="paramname"><em>next_states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>next_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the transition array for the first node with given state and mode.</p>
<p>next_states is an array of state vectors, with length next_len, used to build transitions for this node. All of these states have mode next_mode, and the actual transitions are to the first nodes found with these states and mode.</p>
<p>If the base node already has a transition array, then it is not replaced until the new array has been successfully built. (That is, if error, the original node should be unaffected.)</p>
<p>Return given head on success, NULL if one of the needed nodes is not found. </p>

</div>
</div>
<a class="anchor" id="a1c2058a2959949782553b2f4bf3302fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* delete_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return (possibly new) head pointer. Transition arrays are not altered by this function. </p>

</div>
</div>
<a class="anchor" id="a6003bf5e6d68756a2ff99dfd86d1b2f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_aut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete entire automaton pointed to by given head.</p>
<p>Essentially, traverses node list and frees them and their member data. At completion, the given head pointer is no longer valid. Invoking with NULL pointer causes return with no error. </p>

</div>
</div>
<a class="anchor" id="aa042707aac1b8820ab74ae4272068284"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dot_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>format_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump DOT file describing the automaton (strategy). The appearance can be configured using <a class="el" href="group__DotDumpFlags.html">format flags for dot_aut_dump</a>. Also read comments for <a class="el" href="automaton_8h.html#ad135af09f28e95ad66d501893df662d6">tulip_aut_dump()</a>. </p>

</div>
</div>
<a class="anchor" id="a0921457452ddc98b3fcf28ec8dd9a9c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* find_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return pointer to the first node with given state and mode, or NULL if not found. </p>

</div>
</div>
<a class="anchor" id="a5c6e4b0af816787fd51d57884a58fa93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_anode_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the position of the first node with given state and mode, or -1 if not found. 0-based indexing. </p>

</div>
</div>
<a class="anchor" id="a0ea5d34a7e37ffc8e17a717db52e41e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int forward_modereach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype **&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>magic_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute forward reachable set from given node in automaton, restricting attention to nodes with state in N and goal mode of mode, and setting the mode field of each reached node to magic_mode. Return zero on success, nonzero on error. </p>

</div>
</div>
<a class="anchor" id="a703c9ee45cce2fa6963c08c6e47ae36d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* forward_prune </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> **&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>U_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete nodes in U that are not reachable in the graph from outside U, and then repeat. Nodes marked as initial are ignored; such nodes are supposed to satisfy initial conditions, i.e., from which execution is allowed to begin and hence do not need ingoing edges.</p>
<p>The given array U is altered and freed during execution of <a class="el" href="automaton_8h.html#a703c9ee45cce2fa6963c08c6e47ae36d">forward_prune()</a>, so the caller should not attempt to use it afterward.</p>
<p>U may be redundant, i.e., the implementation is tolerant to U having multiple pointers to the same node.</p>
<p>Return (possibly new) head pointer, or NULL on error. </p>

</div>
</div>
<a class="anchor" id="a37f4ed14e45b2acfbc744d1311a5378f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* insert_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rgrad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initial</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vartype *&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert node at the front of the given node list. If given head is NULL, a new list will be created.</p>
<p>Return new head on success, NULL on error. </p>

</div>
</div>
<a class="anchor" id="acf8e5e021f2e1f64687936957440de5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int json_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump strategy using the current version of the gr1c-JSON file format. Consult <a href="md_formats.html">external_notes</a> for details. </p>

</div>
</div>
<a class="anchor" id="acb0084e8abf09eed89cd7aa2acc03e15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void list_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>state_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump list of nodes; mostly useful for debugging. If fp = NULL, then write to stdout. The basic format is </p><pre class="fragment">i [(init)] : S - m - r - [t0 t1 ...]
</pre><p>where i is the node ID (used only as a means to uniquely refer to nodes), S is the state at that node as comma-separated values, m is the goal mode, r is the reach annotation value, and [t0 t1 ...] is the list of IDs of nodes reachable in one step. The node ID is followed by "(init)" if the initial field is marked True. </p>

</div>
</div>
<a class="anchor" id="aea6e451c56cf9ed34916afa860221490"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structanode__t.html">anode_t</a>* pop_anode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete topmost (head) node from list. Return pointer to new head. </p>

</div>
</div>
<a class="anchor" id="af69834ddebd4ca217886025375182f19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void replace_anode_trans </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>new</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace all occurrences of "old" with "new" in transition arrays. If "new" is NULL, then the transitions into "old" are deleted and all dependent transition array lengths are decremented. </p>

</div>
</div>
<a class="anchor" id="ae85baecde070f1027d3e581df5e74010"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int spin_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>env_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>sys_init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>env_trans_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>et_array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>sys_trans_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>st_array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>env_goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_env_goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>sys_goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_sys_goals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump strategy as Spin Promela model.</p>
<p>Assumptions:</p><ul>
<li>no more than 10000 environment goals;</li>
<li>no more than 10000 system goals;</li>
<li>none of the variables has the following names: checketrans, checkstrans, pmlfault, envinit, envtrans, envgoal0, envgoal1, ... sysinit, systrans, sysgoal0, sysgoal1, ...</li>
</ul>
<p>If fp = NULL, then write to stdout. Return nonzero if error. </p>

</div>
</div>
<a class="anchor" id="a67ce928c0c55d6482bc6b6a0e7135240"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tulip0_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump using tulipcon version 0. DEPRECATED! Please use <a class="el" href="automaton_8h.html#ad135af09f28e95ad66d501893df662d6">tulip_aut_dump()</a> instead. <a class="el" href="automaton_8h.html#a67ce928c0c55d6482bc6b6a0e7135240">tulip0_aut_dump()</a> is provided only for legacy code and will soon be removed. </p>

</div>
</div>
<a class="anchor" id="ad135af09f28e95ad66d501893df662d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tulip_aut_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structanode__t.html">anode_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>evar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>svar_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump tulipcon XML file describing the automaton (strategy). Variable names are obtained from evar_list and svar_list, in which the combined order is assumed to match that of the state vector in each automaton node.</p>
<p>For each node, the goal mode and reach annotation value are placed in a &lt;anno&gt; tag in that order.</p>
<p>If fp = NULL, then write to stdout. Return nonzero if error. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 24 2016 10:24:56 for gr1c by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
