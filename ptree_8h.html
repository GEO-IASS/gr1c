<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>gr1c: ptree.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="gr1cdoc.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gr1c
   &#160;<span id="projectnumber">0.6.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ptree.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Routines for working with a GR(1) formula parse tree.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="common_8h.html">common.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structptree__t.html">ptree_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse tree nodes.  <a href="structptree__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga6349ed07090e8057ed1daea2f15f26e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6349ed07090e8057ed1daea2f15f26e8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_EMPTY</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ga6349ed07090e8057ed1daea2f15f26e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae470b6c1a72050d46b0240c6e28335f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae470b6c1a72050d46b0240c6e28335f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_VARIABLE</b>&#160;&#160;&#160;1</td></tr>
<tr class="separator:gae470b6c1a72050d46b0240c6e28335f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54cdb075307d81ea220e835cdf12fde8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54cdb075307d81ea220e835cdf12fde8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_NEXT_VARIABLE</b>&#160;&#160;&#160;2</td></tr>
<tr class="separator:ga54cdb075307d81ea220e835cdf12fde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177747356bffa4845d930faf0e4c1cfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga177747356bffa4845d930faf0e4c1cfd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_CONSTANT</b>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ga177747356bffa4845d930faf0e4c1cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecba5ac3abe523f3bd5517fef3a5be70"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaecba5ac3abe523f3bd5517fef3a5be70"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_NEG</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:gaecba5ac3abe523f3bd5517fef3a5be70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9dc9b513bea52c22365977321cc11a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab9dc9b513bea52c22365977321cc11a2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_AND</b>&#160;&#160;&#160;5</td></tr>
<tr class="separator:gab9dc9b513bea52c22365977321cc11a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e7dcb8931b363d69e7ed74e5a3a4f65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5e7dcb8931b363d69e7ed74e5a3a4f65"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_OR</b>&#160;&#160;&#160;6</td></tr>
<tr class="separator:ga5e7dcb8931b363d69e7ed74e5a3a4f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f51a52c333c31b9d3b2ae0b76668f0d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8f51a52c333c31b9d3b2ae0b76668f0d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_IMPLIES</b>&#160;&#160;&#160;7</td></tr>
<tr class="separator:ga8f51a52c333c31b9d3b2ae0b76668f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac33d88561c7a1bea76d5e370d78c3992"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac33d88561c7a1bea76d5e370d78c3992"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_EQUALS</b>&#160;&#160;&#160;8</td></tr>
<tr class="separator:gac33d88561c7a1bea76d5e370d78c3992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03faab32bb7f386c5fbf4c3d1653c945"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga03faab32bb7f386c5fbf4c3d1653c945"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_EQUIV</b>&#160;&#160;&#160;9</td></tr>
<tr class="separator:ga03faab32bb7f386c5fbf4c3d1653c945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace6718bd23170139c7ace1b4615a963c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gace6718bd23170139c7ace1b4615a963c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LT</b>&#160;&#160;&#160;10  /* less than, i.e., &quot;&lt;&quot; */</td></tr>
<tr class="separator:gace6718bd23170139c7ace1b4615a963c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga758711b493bd603eec78bfbd794cf2a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga758711b493bd603eec78bfbd794cf2a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_GT</b>&#160;&#160;&#160;11  /* greater than, i.e., &quot;&gt;&quot; */</td></tr>
<tr class="separator:ga758711b493bd603eec78bfbd794cf2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e7b21e52b2a45990fcc517928c28bfb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7e7b21e52b2a45990fcc517928c28bfb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_LE</b>&#160;&#160;&#160;12  /* less than or equal to, i.e., &quot;&lt;=&quot; */</td></tr>
<tr class="separator:ga7e7b21e52b2a45990fcc517928c28bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58c3985c32dd5efc187e060950959f54"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga58c3985c32dd5efc187e060950959f54"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_GE</b>&#160;&#160;&#160;13  /* greater than or equal to, i.e., &quot;&gt;=&quot; */</td></tr>
<tr class="separator:ga58c3985c32dd5efc187e060950959f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54f83ea7d9bd4fa6956eba2516005291"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga54f83ea7d9bd4fa6956eba2516005291"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PT_NOTEQ</b>&#160;&#160;&#160;14  /* not equals */</td></tr>
<tr class="separator:ga54f83ea7d9bd4fa6956eba2516005291"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeffb11122e9c865945360a7038ab859d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeffb11122e9c865945360a7038ab859d"></a>
typedef struct <a class="el" href="structptree__t.html">ptree_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#aeffb11122e9c865945360a7038ab859d">ptree_t</a></td></tr>
<tr class="memdesc:aeffb11122e9c865945360a7038ab859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse tree nodes. <br/></td></tr>
<tr class="separator:aeffb11122e9c865945360a7038ab859d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac029417fbed404f2ce560fffa51beaf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#ac029417fbed404f2ce560fffa51beaf7">init_ptree</a> (int type, char *name, int value)</td></tr>
<tr class="separator:ac029417fbed404f2ce560fffa51beaf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30878b132f25dc77a40f9a62e98729bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a30878b132f25dc77a40f9a62e98729bb">tree_size</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head)</td></tr>
<tr class="separator:a30878b132f25dc77a40f9a62e98729bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ae1907d506910fb09d6c065649a1c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a22ae1907d506910fb09d6c065649a1c4">print_node</a> (<a class="el" href="structptree__t.html">ptree_t</a> *node, FILE *fp)</td></tr>
<tr class="separator:a22ae1907d506910fb09d6c065649a1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab667656ec259d42be9768c401458805b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#ab667656ec259d42be9768c401458805b">inorder_trav</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, void(*node_fn)(<a class="el" href="structptree__t.html">ptree_t</a> *, void *), void *arg)</td></tr>
<tr class="separator:ab667656ec259d42be9768c401458805b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa42c7959656ccdd2b1c16302e18be7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a7fa42c7959656ccdd2b1c16302e18be7">print_formula</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, FILE *fp)</td></tr>
<tr class="separator:a7fa42c7959656ccdd2b1c16302e18be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13bfe48b3b350e90785d382a7ea2918d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a13bfe48b3b350e90785d382a7ea2918d">merge_ptrees</a> (<a class="el" href="structptree__t.html">ptree_t</a> **heads, int len, int type)</td></tr>
<tr class="separator:a13bfe48b3b350e90785d382a7ea2918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca77712054f6a4107bc3f0154d174ff"><td class="memItemLeft" align="right" valign="top">DdNode *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a5ca77712054f6a4107bc3f0154d174ff">ptree_BDD</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *var_list, DdManager *manager)</td></tr>
<tr class="separator:a5ca77712054f6a4107bc3f0154d174ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8632c58da19ad428dabd36e8c5325c1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a8632c58da19ad428dabd36e8c5325c1e">tree_dot_dump</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, char *filename)</td></tr>
<tr class="separator:a8632c58da19ad428dabd36e8c5325c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e85d3f26e47440f53bf401b2625a83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a09e85d3f26e47440f53bf401b2625a83">delete_tree</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head)</td></tr>
<tr class="separator:a09e85d3f26e47440f53bf401b2625a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4b88da22f7aa227961eb8052b0b358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#aed4b88da22f7aa227961eb8052b0b358">min_tree_value</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head)</td></tr>
<tr class="separator:aed4b88da22f7aa227961eb8052b0b358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc2f16adc9a33681af5e4c879482c4c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a1cc2f16adc9a33681af5e4c879482c4c">max_tree_value</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head)</td></tr>
<tr class="separator:a1cc2f16adc9a33681af5e4c879482c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18e9cef7171d4560c86bfbdeb7aa38f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#aa18e9cef7171d4560c86bfbdeb7aa38f">rmin_tree_value</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, char *name)</td></tr>
<tr class="separator:aa18e9cef7171d4560c86bfbdeb7aa38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cc0b8b8aa96dcf8b31e9dbf62fb95c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a91cc0b8b8aa96dcf8b31e9dbf62fb95c">rmax_tree_value</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, char *name)</td></tr>
<tr class="separator:a91cc0b8b8aa96dcf8b31e9dbf62fb95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaba06e25428c972a57bca6785b1922"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#accaba06e25428c972a57bca6785b1922">check_vars</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, <a class="el" href="structptree__t.html">ptree_t</a> *var_list, <a class="el" href="structptree__t.html">ptree_t</a> *nextvar_list)</td></tr>
<tr class="separator:accaba06e25428c972a57bca6785b1922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f0cbc31bd000f3cc7d54f9025d308f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#ae7f0cbc31bd000f3cc7d54f9025d308f">var_to_bool</a> (char *name, int maxval)</td></tr>
<tr class="separator:ae7f0cbc31bd000f3cc7d54f9025d308f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b9a8f9772d6d48a5fb69c7418f6906"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#af7b9a8f9772d6d48a5fb69c7418f6906">expand_to_bool</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, char *name, int maxval)</td></tr>
<tr class="separator:af7b9a8f9772d6d48a5fb69c7418f6906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45bda40e09c6e412d64b38bc7a57dd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#af45bda40e09c6e412d64b38bc7a57dd6">unreach_expanded_bool</a> (char *name, int lower, int upper, int type)</td></tr>
<tr class="separator:af45bda40e09c6e412d64b38bc7a57dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91871715a40802631f35fcc755240e49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a91871715a40802631f35fcc755240e49">pusht_terminal</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int type, char *name, int value)</td></tr>
<tr class="separator:a91871715a40802631f35fcc755240e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee9c6d601fdfcb42181e24f1a59505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a43ee9c6d601fdfcb42181e24f1a59505">pusht_operator</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int type)</td></tr>
<tr class="separator:a43ee9c6d601fdfcb42181e24f1a59505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec3ab9b5f6928970bf419384d05a7da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#afec3ab9b5f6928970bf419384d05a7da">append_list_item</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int type, char *name, int value)</td></tr>
<tr class="separator:afec3ab9b5f6928970bf419384d05a7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2031cfade02e94a3a7a38d7d593890d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a2031cfade02e94a3a7a38d7d593890d6">remove_list_item</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int index)</td></tr>
<tr class="separator:a2031cfade02e94a3a7a38d7d593890d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af21185cb2323bfb4582c6ddacc4469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#a9af21185cb2323bfb4582c6ddacc4469">get_list_item</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int index)</td></tr>
<tr class="separator:a9af21185cb2323bfb4582c6ddacc4469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4aad181edffc721e3c12e4d5b5ccdfc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ptree_8h.html#ac4aad181edffc721e3c12e4d5b5ccdfc">find_list_item</a> (<a class="el" href="structptree__t.html">ptree_t</a> *head, int type, char *name, int value)</td></tr>
<tr class="separator:ac4aad181edffc721e3c12e4d5b5ccdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Routines for working with a GR(1) formula parse tree. </p>
<p>To avoid defining another basic data structure, we may effectively obtain a linked list by making a binary tree with no right children (or more generally, a tree in which each node has at most one child). Functions intended specifically to support this use case include "list" in their names.</p>
<p>For functions concerning tree nodes, any arguments that are not applicable to the given type are ignored.</p>
<p>SCL; 2012-2014. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afec3ab9b5f6928970bf419384d05a7da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* append_list_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return pointer to new item (which is of course accessible via given root node). If argument head is NULL, then behave exactly as <a class="el" href="ptree_8h.html#ac029417fbed404f2ce560fffa51beaf7">init_ptree()</a> (and thus, a new tree root node is returned). </p>

</div>
</div>
<a class="anchor" id="accaba06e25428c972a57bca6785b1922"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* check_vars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>var_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>nextvar_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Verify that every variable (resp., next variable) in given parse tree is contained in var_list (resp., nextvar_list). Return NULL if successfully verified; else, return a pointer to a string of a violating variable, which the caller is expected to free. </p>

</div>
</div>
<a class="anchor" id="a09e85d3f26e47440f53bf401b2625a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_tree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete tree with given root node. </p>

</div>
</div>
<a class="anchor" id="af7b9a8f9772d6d48a5fb69c7418f6906"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* expand_to_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand all occurrences of name (a variable) in formula described by the tree head, replacing by Boolean variables as would be found by <a class="el" href="ptree_8h.html#ae7f0cbc31bd000f3cc7d54f9025d308f">var_to_bool()</a>. Changes are made in-place.</p>
<p>Return the (possibly new) head pointer, or NULL if error. </p>

</div>
</div>
<a class="anchor" id="ac4aad181edffc721e3c12e4d5b5ccdfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int find_list_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return index (0-base) to first match in list, or -1 if not found. </p>

</div>
</div>
<a class="anchor" id="a9af21185cb2323bfb4582c6ddacc4469"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* get_list_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>0-based indexing. An index of -1 refers to the last item in the list. Return pointer to the node, or NULL on error. </p>

</div>
</div>
<a class="anchor" id="ac029417fbed404f2ce560fffa51beaf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* init_ptree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create root node with given type. Return NULL on error. </p>

</div>
</div>
<a class="anchor" id="ab667656ec259d42be9768c401458805b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inorder_trav </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(<a class="el" href="structptree__t.html">ptree_t</a> *, void *)&#160;</td>
          <td class="paramname"><em>node_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverse the tree in-order, calling *node_fn at each node and passing it arg. </p>

</div>
</div>
<a class="anchor" id="a1cc2f16adc9a33681af5e4c879482c4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int max_tree_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum value among PT_CONSTANT nodes in given tree.</p>
<p>Also see documentation for <a class="el" href="ptree_8h.html#aed4b88da22f7aa227961eb8052b0b358">min_tree_value()</a>. </p>

</div>
</div>
<a class="anchor" id="a13bfe48b3b350e90785d382a7ea2918d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* merge_ptrees </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> **&#160;</td>
          <td class="paramname"><em>heads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new tree in which all of the given trees are included by the specified binary operator. len is the length of heads. Return pointer to the new tree root, or NULL on error. N.B., the given trees are <em>pointed to</em> by the new tree, i.e, their roots become nodes in the new tree, and therefore you generally should <em>not</em> try to free the originals (but can discard the old heads pointers). </p>

</div>
</div>
<a class="anchor" id="aed4b88da22f7aa227961eb8052b0b358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int min_tree_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the minimum value among PT_CONSTANT nodes in given tree.</p>
<p>N.B., -9999 is used as a special indicator value to allow <a class="el" href="ptree_8h.html#aed4b88da22f7aa227961eb8052b0b358">min_tree_value()</a> to work on the tree recursively.</p>
<p>If head is NULL or there are not any PT_CONSTANT nodes, then the output is undefined. </p>

</div>
</div>
<a class="anchor" id="a7fa42c7959656ccdd2b1c16302e18be7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_formula </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If f is NULL, then use stdout. </p>

</div>
</div>
<a class="anchor" id="a22ae1907d506910fb09d6c065649a1c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If f is NULL, then use stdout. </p>

</div>
</div>
<a class="anchor" id="a5ca77712054f6a4107bc3f0154d174ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DdNode* ptree_BDD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>var_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DdManager *&#160;</td>
          <td class="paramname"><em>manager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate BDD corresponding to given parse tree. var_list is the linked list of variable names to refer to; ordering in var_list determines index in the BDD. Non-Boolean variables and equality are not supported. fn should be NULL, unless you wish to initialize with a non-constant-True function.</p>
<p>Any primed variables (type of PT_NEXT_VARIABLE) will be given an index corresponding to unprimed variables but offset by the total number of variables (length of list var_list). </p>

</div>
</div>
<a class="anchor" id="a43ee9c6d601fdfcb42181e24f1a59505"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* pusht_operator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push unary or binary operator into top of tree. (Behavior is like reverse Polish notation.) Return the new head. </p>

</div>
</div>
<a class="anchor" id="a91871715a40802631f35fcc755240e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* pusht_terminal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Push variable or constant into top of tree. (Behavior is like reverse Polish notation.) Return the new head. </p>

</div>
</div>
<a class="anchor" id="a2031cfade02e94a3a7a38d7d593890d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* remove_list_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>0-based indexing. An index of -1 refers to the last item in the list. Return pointer to parent of removed node if non-root, or to item with original index of 1 if root.</p>
<p>If head is NULL (i.e., tree is empty), then print a warning and return NULL. If index is outside of possible range, then print warning and return NULL. </p>

</div>
</div>
<a class="anchor" id="a91cc0b8b8aa96dcf8b31e9dbf62fb95c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rmax_tree_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="ptree_8h.html#a1cc2f16adc9a33681af5e4c879482c4c">max_tree_value()</a> but restrict attention to specified variable. </p>

</div>
</div>
<a class="anchor" id="aa18e9cef7171d4560c86bfbdeb7aa38f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rmin_tree_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <a class="el" href="ptree_8h.html#aed4b88da22f7aa227961eb8052b0b358">min_tree_value()</a> but restrict attention to specified variable. </p>

</div>
</div>
<a class="anchor" id="a8632c58da19ad428dabd36e8c5325c1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tree_dot_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate Graphviz DOT file depicting the parse tree. Return 0 on success, -1 on error. </p>

</div>
</div>
<a class="anchor" id="a30878b132f25dc77a40f9a62e98729bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tree_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structptree__t.html">ptree_t</a> *&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return number of nodes in tree. </p>

</div>
</div>
<a class="anchor" id="af45bda40e09c6e412d64b38bc7a57dd6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* unreach_expanded_bool </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create tree describing unreachable values of a nonboolean-expanded-to-boolean variable. E.g., this can be used to handle "don't care" values that appear as a side-effect of conversion to a bitvector. The formula corresponding to the tree is of the form !(v = k1) &amp; !(v = k2) &amp; ... where k1 &lt; k2 &lt; ... are values in the range [lower, upper] (inclusive). type should be one PT_VARIABLE or PT_NEXT_VARIABLE. </p>

</div>
</div>
<a class="anchor" id="ae7f0cbc31bd000f3cc7d54f9025d308f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structptree__t.html">ptree_t</a>* var_to_bool </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>name is a variable with domain {0,...,maxval}, where we assume that maxval is at least 2. Return a list of variables in order of increasing bit index, e.g., invoking with a variable named "foo" and maxval=2 causes a list to be returned of the form foo0,foo1.</p>
<p>Return NULL on error. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 19 2014 11:36:09 for gr1c by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3.1
</small></address>
</body>
</html>
